class GridToFullscreenEffect{constructor(e,t,i={}){this.container=e,this.itemsWrapper=t,this.itemsWrapperChildren=t.querySelectorAll(".trigger-item"),this.initialised=!1,this.camera=null,this.scene=null,this.renderer=null,i.scrollContainer=i.scrollContainer||null,i.timing=i.timing||{},i.timing.type=i.timing.type||"sameEnd",i.timing.sections=i.timing.sections||1,i.timing.latestStart=i.timing.latestStart||.5,i.timing.duration=i.timing.duration||1,i.transformation=i.transformation||{},i.transformation.type=i.transformation.type||"none",i.transformation.props=i.transformation.props||{},i.activation.type=i.activation.type||"topLeft",i.seed=i.seed||0,i.easings=i.easings||{},i.easings.toFullscreen=i.easings.toFullscreen||Power0.easeNone,i.easings.toGrid=i.easings.toGrid||Power0.easeNone,i.flipBeizerControls=i.flipBeizerControls||{},i.flipBeizerControls.c0=i.flipBeizerControls.c0||{},i.flipBeizerControls.c0.x=i.flipBeizerControls.c0.x||.5,i.flipBeizerControls.c0.y=i.flipBeizerControls.c0.y||.5,i.flipBeizerControls.c1=i.flipBeizerControls.c1||{},i.flipBeizerControls.c1.x=i.flipBeizerControls.c1.x||.5,i.flipBeizerControls.c1.y=i.flipBeizerControls.c1.y||.5,this.options=i,this.uniforms={uImage:new THREE.Uniform(null),uImageRes:new THREE.Uniform(new THREE.Vector2(1,1)),uImageLarge:new THREE.Uniform(null),uImageLargeRes:new THREE.Uniform(new THREE.Vector2(1,1)),uProgress:new THREE.Uniform(0),uMeshScale:new THREE.Uniform(new THREE.Vector2(1,1)),uPlaneCenter:new THREE.Uniform(new THREE.Vector2(0,0)),uViewSize:new THREE.Uniform(new THREE.Vector2(1,1)),uScaleToViewSize:new THREE.Uniform(new THREE.Vector2(1,1)),uClosestCorner:new THREE.Uniform(0),uMouse:new THREE.Uniform(new THREE.Vector2(0,0)),uSeed:new THREE.Uniform(i.seed),uProgressByParts:new THREE.Uniform("sections"===i.timing.type),uActivationParts:new THREE.Uniform(i.timing.sections),uSyncLatestStart:new THREE.Uniform(i.timing.latestStart),uBeizerControls:new THREE.Uniform(new THREE.Vector4(i.flipBeizerControls.c0.x,i.flipBeizerControls.c0.y,i.flipBeizerControls.c1.x,i.flipBeizerControls.c1.y))},this.textures=[],this.currentImageIndex=-1,this.isFullscreen=!1,this.isAnimating=!1,this.onResize=this.onResize=this.onResize.bind(this)}resetUniforms(){this.uniforms.uMeshScale.value=new THREE.Vector2(1,1),this.uniforms.uPlaneCenter.value=new THREE.Vector2(0,0),this.uniforms.uScaleToViewSize.value=new THREE.Vector2(1,1),this.uniforms.uClosestCorner.value=0,this.uniforms.uMouse.value=new THREE.Vector2(0,0),this.uniforms.uImage.value=null,this.uniforms.uImageRes.value=new THREE.Vector2(1,1),this.uniforms.uImageLarge.value=null,this.uniforms.uImageLargeRes.value=new THREE.Vector2(1,1);var e=this.mesh;e.scale.x=1e-5,e.scale.y=1e-5,e.position.x=0,e.position.y=0}createTextures(t){var i=[];for(let e=0;e<t.length;e++){var r=t[e],o=new THREE.Texture(r.large.image),s=(o.generateMipmaps=!1,o.wrapS=o.wrapT=THREE.ClampToEdgeWrapping,o.minFilter=THREE.LinearFilter,o.needsUpdate=!0,new THREE.Texture(r.small.image)),o=(s.generateMipmaps=!1,s.wrapS=s.wrapT=THREE.ClampToEdgeWrapping,s.minFilter=THREE.LinearFilter,s.needsUpdate=!0,{large:{element:r.large.element,texture:o},small:{element:r.small.element,texture:s}});i.push(o)}this.textures=i,this.setCurrentTextures()}setCurrentTextures(){var e;-1===this.currentImageIndex||(e=this.textures[this.currentImageIndex],this.uniforms.uImage.value=e.small.texture,this.uniforms.uImageRes.value.x=e.small.texture.image.naturalWidth,this.uniforms.uImageRes.value.y=e.small.texture.image.naturalHeight,this.uniforms.uImageLarge.value=e.large.texture,this.uniforms.uImageLargeRes.value.x=e.large.texture.image.naturalWidth,this.uniforms.uImageLargeRes.value.y=e.large.texture.image.naturalHeight,this.isAnimating)||this.render()}init(){this.renderer=new THREE.WebGLRenderer({alpha:!0,antialias:!0}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(window.innerWidth,window.innerHeight),this.container.appendChild(this.renderer.domElement),this.scene=new THREE.Scene,this.camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,.1,1e4),this.camera.position.z=50,this.camera.lookAt=this.scene.position;var e=this.getViewSize(),e=(this.uniforms.uViewSize.value=new THREE.Vector2(e.width,e.height),new THREE.PlaneBufferGeometry(1,1,128,128));var t=(t=this.options.transformation.type)&&"[object Function]"==={}.toString.call(t)?this.options.transformation.type(this.options.transformation.props):transformations[this.options.transformation.type](this.options.transformation.props),t=generateShaders(activations[this.options.activation.type],t),t=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:t.vertex,fragmentShader:t.fragment,side:THREE.DoubleSide});this.mesh=new THREE.Mesh(e,t),this.scene.add(this.mesh),window.addEventListener("resize",this.onResize),this.options.scrollContainer&&this.options.scrollContainer.addEventListener("scroll",e=>{this.recalculateUniforms(e)});for(let e=0;e<this.itemsWrapperChildren.length;e++)this.itemsWrapperChildren[e].children[0].addEventListener("mousedown",this.createOnMouseDown(e))}createOnMouseDown(t){return e=>{this.toFullscreen(t,e)}}toGrid(){this.isFullscreen&&!this.isAnimating&&(this.isAnimating=!0,this.options.onToGridStart&&this.options.onToGridStart({index:this.currentImageIndex}),this.tween=TweenLite.to(this.uniforms.uProgress,this.options.timing.duration,{value:0,ease:this.options.easings.toGrid,onUpdate:()=>{this.render()},onComplete:()=>{this.isAnimating=!1,this.isFullscreen=!1,this.itemsWrapper.style.zIndex=1,this.container.style.zIndex=0,this.resetUniforms(),this.render(),this.options.onToGridFinish&&this.options.onToGridFinish({index:-1,lastIndex:this.currentImageIndex}),this.currentImageIndex=-1}}))}recalculateUniforms(e){var t,i,r,o,s;-1!==this.currentImageIndex&&(s=this.itemsWrapperChildren[this.currentImageIndex].children[0].getBoundingClientRect(),e={x:(e.clientX-s.left)/s.width,y:1-(e.clientY-s.top)/s.height},t=s.left>window.innerWidth-(s.left+s.width),i=s.top>window.innerHeight-(s.top+s.height),this.uniforms.uClosestCorner.value=2*t+i,this.uniforms.uMouse.value=new THREE.Vector2(e.x,e.y),t=this.getViewSize(),i=s.width*t.width/window.innerWidth,e=s.height*t.height/window.innerHeight,r=s.left*t.width/window.innerWidth-t.width/2,s=s.top*t.height/window.innerHeight-t.height/2,this.mesh.geometry,o=r+((r=this.mesh).scale.x=i)/2,s=-s-(r.scale.y=e)/2,r.position.x=o,r.position.y=s,this.uniforms.uPlaneCenter.value.x=o/i,this.uniforms.uPlaneCenter.value.y=s/e,this.uniforms.uMeshScale.value.x=i,this.uniforms.uMeshScale.value.y=e,this.uniforms.uScaleToViewSize.value.x=t.width/i-1,this.uniforms.uScaleToViewSize.value.y=t.height/e-1)}toFullscreen(e,t){this.isFullscreen||this.isAnimating||(this.isAnimating=!0,this.currentImageIndex=e,this.recalculateUniforms(t),this.textures[e]&&(t=this.textures[e],this.uniforms.uImage.value=t.small.texture,this.uniforms.uImageRes.value.x=t.small.texture.image.naturalWidth,this.uniforms.uImageRes.value.y=t.small.texture.image.naturalHeight,this.uniforms.uImageLarge.value=t.large.texture,this.uniforms.uImageLargeRes.value.x=t.large.texture.image.naturalWidth,this.uniforms.uImageLargeRes.value.y=t.large.texture.image.naturalHeight),this.itemsWrapper.style.zIndex=0,this.container.style.zIndex=2,this.options.onToFullscreenStart&&this.options.onToFullscreenStart({index:this.currentImageIndex}),this.tween=TweenLite.to(this.uniforms.uProgress,this.options.timing.duration,{value:1,ease:this.options.easings.toFullscreen,onUpdate:()=>{this.render()},onComplete:()=>{this.isAnimating=!1,this.isFullscreen=!0,this.options.onToFullscreenFinish&&this.options.onToFullscreenFinish({index:this.currentImageIndex})}}))}getViewSize(){var e=this.camera.fov*Math.PI/180,e=Math.abs(this.camera.position.z*Math.tan(e/2)*2);return{width:e*this.camera.aspect,height:e}}render(){this.renderer.render(this.scene,this.camera)}onResize(e){this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.renderer.setSize(window.innerWidth,window.innerHeight),-1<this.currentImageIndex&&(this.recalculateUniforms(e),this.render())}}var activations={corners:`
    float getActivation(vec2 uv){
      float top = (1.-uv.y);
      float right = uv.x;
      float bottom = uv.y;
      float left = 1.- uv.x;

      return top *0.333333 + (right * 0.333333 + (right * bottom)*0.666666 );
  }
  `,topLeft:`
    float getActivation(vec2 uv){
        return (+uv.x-uv.y+1.)/2.;
    }
  `,sides:`
      float getActivation(vec2 uv){
        return min(uv.x, 1.-uv.x) * 2.;
      }
  `,left:`
    float getActivation(vec2 uv){
        return uv.x;
    }
    `,top:`
    float getActivation(vec2 uv){
        return 1. - uv.y;
    }
    `,bottom:`
    float getActivation(vec2 uv){
        return uv.y;
    }
    `,bottomStep:`
    float getActivation(vec2 uv){
        
        
        return uv.y;
    }
    `,sinX:`
      float getActivation(vec2 uv){
        return sin(uv.x * 3.14);
      }
    `,center:`
      float getActivation(vec2 uv){
        float maxDistance = distance(vec2(0.),vec2(0.5));
        float dist = distance(vec2(0.), uv-0.5);
        return smoothstep(0.,maxDistance,dist);
      }
    `,mouse:`
      float getActivation(vec2 uv){
        float maxDistance = distance(uMouse, 1.-floor(uMouse+0.5));
        float dist = smoothstep(0.,maxDistance,distance(uMouse,uv));
        return dist;
      }
    `,closestCorner:`
      float getActivation(vec2 uv){

        float y = mod(uClosestCorner,2.) *2. -1.;
        float x = (floor(uClosestCorner /2.)*2.-1.)*-1.;

        float xAct = abs(min(0.,x)) + uv.x * x;
        float yAct = abs(min(0.,y)) + uv.y * y;

        return (xAct+yAct)/2.;
      }
    `,closestSide:`
      float getActivation(vec2 uv){

        float y = mod(uClosestCorner,2.) *2. -1.;
        float x = (floor(uClosestCorner /2.)*2.-1.)*-1.;

        float xAct = abs(min(0.,x)) + uv.x * x;
        float yAct = abs(min(0.,y)) + uv.y * y;

        return (xAct+yAct)/2.;
      }
    `};function ensureFloat(e){let t=e.toString();return-1===t.indexOf(".")&&(t+="."),t}const transformations={none:()=>null,flipX:()=>`
    
        float beizerProgress = cubicBezier(vertexProgress,
        uBeizerControls.x,uBeizerControls.y,
        uBeizerControls.z,uBeizerControls.w);

        float flippedX = -transformedPos.x;
        transformedPos.x = mix (transformedPos.x, flippedX,beizerProgress );
          
          // Flip texture on flipped sections 
        // float activationAtX0 = getActivation(vec2(0.,transformedUV.y));
        // float activationAtX1 = getActivation(vec2(1.,transformedUV.y));
        //   float syncDifference = 
        //     activationAtX1 * uSyncLatestStart - activationAtX0 * uSyncLatestStart;
          float syncDifference =  uSyncLatestStart;
            
            // Flip the controls because who knows why
            // But it works exactly

          // Multiply by aspect ratio to account for mesh scaling
          float aspectRatio = (uMeshScale.x / uMeshScale.y);
          float stepFormula = 0.5 - (syncDifference * uSyncLatestStart * uSyncLatestStart) * aspectRatio;

          transformedUV.x = mix(transformedUV.x,1.-transformedUV.x,
              step(stepFormula,beizerProgress));
      `,simplex:e=>{ensureFloat(e.seed||0);var t=ensureFloat(e.amplitudeX||.5),i=ensureFloat(e.amplitudeY||.5),r=ensureFloat(e.frequencyX||1),o=ensureFloat(e.frequencyY||.75),e=ensureFloat(e.progressLimit||.5);return`
      float simplexProgress = min(clamp((vertexProgress) / ${e},0.,1.),clamp((1.-vertexProgress) / (1.-${e}),0.,1.));
      simplexProgress = smoothstep(0.,1.,simplexProgress);
      float noiseX = snoise(vec2(transformedPos.x +uSeed, transformedPos.y + uSeed + simplexProgress * 1.) * ${r} ) ;
      float noiseY = snoise(vec2(transformedPos.y +uSeed, transformedPos.x + uSeed + simplexProgress * 1.) * ${o}) ;
      transformedPos.x += ${t} * noiseX * simplexProgress;
      transformedPos.y += ${i} * noiseY * simplexProgress;
  `},wavy:e=>{var t=ensureFloat(e.seed||0);return`
      float limit = 0.5;
      float wavyProgress = min(clamp((vertexProgress) / limit,0.,1.),clamp((1.-vertexProgress) / (1.-limit),0.,1.));

      float dist = length(transformedPos.xy);
      
      float angle = atan(transformedPos.x,transformedPos.y);

      float nextDist = dist * (${ensureFloat(e.amplitude||.5)} * (sin(angle * ${ensureFloat(e.frequency||4)} + ${t}) /2.+0.5)+ 1.);

      transformedPos.x = mix(transformedPos.x,sin(angle) * nextDist ,  wavyProgress);
      transformedPos.y = mix(transformedPos.y,cos(angle) * nextDist,  wavyProgress);
    `},circle:e=>`
      float limit = 0.5;
      float circleProgress = min(clamp((vertexProgress) / limit,0.,1.),clamp((1.-vertexProgress) / (1.-limit),0.,1.));

      float maxDistance = 0.5;
      float dist = length(transformedPos.xy);
      
      float nextDist = min(maxDistance,dist);
      float overload = step(maxDistance,dist);
      float angle = atan(transformedPos.x,transformedPos.y);
      
      transformedPos.x = mix(transformedPos.x,sin(angle) * nextDist ,  circleProgress );
      transformedPos.y = mix(transformedPos.y,cos(angle) * nextDist,  circleProgress);
      transformedPos.z += -0.5 * overload * circleProgress;
    
  `};var vertexUniforms=`
    uniform float uProgress;
    uniform vec2 uScaleToViewSize;
    uniform vec2 uPlaneCenter;
    uniform vec2 uMeshScale;
    uniform vec2 uMouse;
    uniform vec2 uViewSize;

    uniform float uClosestCorner;

    // Option Uniforms
    uniform float uSeed;
    uniform vec4 uBeizerControls;
    uniform float uSyncLatestStart;
    uniform float uActivationParts;
    uniform bool uProgressByParts;
    varying vec2 vUv;
    varying vec2 scale; 
    varying float vProgress;
`;function generateShaders(e,t){return{fragment:`
    uniform float uProgress;
    uniform sampler2D uImage;
    uniform vec2 uImageRes;
    uniform sampler2D uImageLarge;
    uniform vec2 uImageLargeRes;
    uniform vec2 uMeshScale;
    
    varying vec2 vUv;
    varying float vProgress;
    varying vec2 scale;


    vec2 preserveAspectRatioSlice(vec2 uv, vec2 planeSize, vec2 imageSize ){
      
        vec2 ratio = vec2(
            min((planeSize.x / planeSize.y) / (imageSize.x / imageSize.y), 1.0),
            min((planeSize.y / planeSize.x) / (imageSize.y / imageSize.x), 1.0)
        );
        
        
        vec2 sliceUvs = vec2(
            uv.x * ratio.x + (1.0 - ratio.x) * 0.5,
            uv.y * ratio.y + (1.0 - ratio.y) * 0.5
        );

        return sliceUvs;
    }

    void main(){
 
        vec2 uv = vUv;

        vec2 scaledPlane = uMeshScale * scale;

        
        vec2 smallImageUV = preserveAspectRatioSlice(uv, scaledPlane, uImageRes);

        vec3 color = texture2D(uImage,smallImageUV).xyz;

        if(vProgress > 0.){
          vec2 largeImageUV = preserveAspectRatioSlice(uv, scaledPlane, uImageLargeRes);
          color = mix(color,texture2D(uImageLarge,largeImageUV).xyz, vProgress );
        }

        gl_FragColor = vec4(color,1.);
    }
`,vertex:`
    ${vertexUniforms}
    ${cubicBeizer}
    ${simplex}

    ${quadraticBezier}
    

    ${e}
float linearStep(float edge0, float edge1, float val) {
	float x = clamp( (val  - edge0) / (edge1 - edge0),0.,1.);
		return x;
}
    void main(){

      vec3 pos = position.xyz;
      vec2 newUV = uv;

      float activation = getActivation(uv);



      // Everything ends at the same time
      float startAt = activation * uSyncLatestStart;
      float vertexProgress = smoothstep(startAt,1.,uProgress);


      if(uProgressByParts){
        // Vertex end by parts
        float activationPart = 1./uActivationParts;
        float activationPartDuration = 1./(uActivationParts+1.);

        float progressStart = (activation / activationPart) * activationPartDuration;
        float progressEnd = min(progressStart + activationPartDuration,1.);
        vertexProgress = linearStep(progressStart,progressEnd,uProgress);
      }
        vec3 transformedPos = pos;
        vec2 transformedUV = uv;
        ${t||""}
        pos = transformedPos;
        newUV = transformedUV; 

        // Scale
        // uScaleToViewSize
        scale = vec2(
          1. + uScaleToViewSize * vertexProgress
        );
        // Since we are moving the mesh not the geometry the geometry is in the center
        
        vec2 flippedPos = vec2(
          (- pos.x) ,
          (- pos.y ) 
        );


        
        pos.xy *= scale;


        // Move to center
        // Mesh moves it into position. Shader moves it to the center
        pos.y += -uPlaneCenter.y * vertexProgress;
        pos.x += -uPlaneCenter.x * vertexProgress;

        // Move slightly to the front
        pos.z += vertexProgress;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.);
        vProgress = vertexProgress;
      vUv = newUV;
    }
`}}var cubicBeizer=`
// Helper functions:
float slopeFromT (float t, float A, float B, float C){
  float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); 
  return dtdx;
}

float xFromT (float t, float A, float B, float C, float D){
  float x = A*(t*t*t) + B*(t*t) + C*t + D;
  return x;
}

float yFromT (float t, float E, float F, float G, float H){
  float y = E*(t*t*t) + F*(t*t) + G*t + H;
  return y;
}
float cubicBezier (float x, float a, float b, float c, float d){

  float y0a = 0.00; // initial y
  float x0a = 0.00; // initial x 
  float y1a = b;    // 1st influence y   
  float x1a = a;    // 1st influence x 
  float y2a = d;    // 2nd influence y
  float x2a = c;    // 2nd influence x
  float y3a = 1.00; // final y 
  float x3a = 1.00; // final x 

  float A =   x3a - 3.*x2a + 3.*x1a - x0a;
  float B = 3.*x2a - 6.*x1a + 3.*x0a;
  float C = 3.*x1a - 3.*x0a;   
  float D =   x0a;

  float E =   y3a - 3.*y2a + 3.*y1a - y0a;    
  float F = 3.*y2a - 6.*y1a + 3.*y0a;             
  float G = 3.*y1a - 3.*y0a;             
  float H =   y0a;

  // Solve for t given x (using Newton-Raphelson), then solve for y given t.
  // Assume for the first guess that t = x.
  float currentt = x;
  const int nRefinementIterations = 5;
  for (int i=0; i < nRefinementIterations; i++){
    float currentx = xFromT (currentt, A,B,C,D); 
    float currentslope = slopeFromT (currentt, A,B,C);
    currentt -= (currentx - x)*(currentslope);
    currentt = clamp(currentt, 0.,1.);
  } 

  float y = yFromT (currentt,  E,F,G,H);
  return y;
}
`,simplex=`
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  const vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}
`,quadraticBezier=`
float quadraticBezier (float x, float a, float b){
  // adapted from BEZMATH.PS (1993)
  // by Don Lancaster, SYNERGETICS Inc. 
  // http://www.tinaja.com/text/bezmath.html

  float epsilon = 0.00001;
  a = max(0., min(1., a)); 
  b = max(0., min(1., b)); 
  if (a == 0.5){
    a += epsilon;
  }
  
  // solve t from x (an inverse operation)
  float om2a = 1. - 2.*a;
  float t = (sqrt(a*a + om2a*x) - a)/om2a;
  float y = (1.-2.*b)*(t*t) + (2.*b)*t;
  return y;
}
`;